---
title: "Demonstation: Sequential vs. combinaed analysis"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Libraries
library(ggplot2)
library(knitr)
library(brms)

# Loading data
load("U:/Projects/schemaVR/schemaVR_paper/scriptsOutput/ demonstration_sequential_vs_combined_20191011_110314.RData")
```

# Aim 
The aim of this document is to demonstrate that sequentally analysing data with Bayesian models (i.e. using posteriors as priors) is equivalent to combining data. 

# Script used
```{r eval = FALSE}
# The aim of this script is to show that sequantial analysis (using psoteriors as priors) is equivalent to 
# combining datasets and running in one go.

# Libraies
library(brms)
library(assortedRFunctions)
cores2use <- 4

# Generating data 1
n1      <- 100
beta1.0 <- 0
beta1.1 <- 0.5
x       <- runif(n1, -1, 1)
y       <- beta1.0 + beta1.1*x + rnorm(n1, 0, 1)
data1 <- data.frame(x, y)

# Generating data 2
n2      <- 90
beta2.0 <- 0.1
beta2.1 <- 0.3
x       <- runif(n2, -1, 1)
y       <- beta2.0 + beta2.1*x + rnorm(n2, 0, 1)
data2 <- data.frame(scax, y)

# Combining data sets
data_combined <- rbind(data1, data2)

# Sequential analysis
# Data 1
initial_priors <- c(prior(normal(0, 1), class = "Intercept"),
                    prior(normal(0, 1), class = "b")) 
m_data1 <- brm(y ~ x, 
               data = data1,
               prior = initial_priors,
               cores = cores2use,
               save_all_pars = TRUE,
               sample_prior = TRUE)

# Data 2
m_data1_fixef <- fixef(m_data1)
priors_data2  <- c(set_prior(priorString_normal(m_data1_fixef[1, 1], m_data1_fixef[1, 2]),
                                       class = "Intercept"),
                             set_prior(priorString_normal(m_data1_fixef[2, 1], m_data1_fixef[2, 2]),
                                       class = "b",
                                       coef = "x"))
m_data2 <- brm(y ~ x, 
               data = data2,
               prior = priors_data2,
               cores = cores2use,
               save_all_pars = TRUE,
               sample_prior = TRUE)

# Combined analysis
m_data_combined <- brm(y ~ x, 
               data = data_combined ,
               prior = initial_priors,
               cores = cores2use,
               save_all_pars = TRUE,
               sample_prior = TRUE)

# Saving results
save.image(datedFileNam('scriptsOutput/ demonstration_sequential_vs_combined', '.RData'))
```

# Comparing posterior distributions
```{r}
postDist_m_data2         <- posterior_samples(m_data2)
postDist_m_data_combined <- posterior_samples(m_data_combined)
nSamples                 <- dim(postDist_m_data_combined)[1]
postDist_comparison      <- data.frame(Approach = c(rep('sequential', nSamples), 
                                                    rep('combined', nSamples)),
                                       b_Intercept = c(postDist_m_data2$b_Intercept, 
                                                       postDist_m_data_combined$b_Intercept),
                                       b_x         = c(postDist_m_data2$b_x, 
                                                       postDist_m_data_combined$b_x))

ggplot(postDist_comparison, aes(x = b_Intercept, colour = Approach, fill = Approach)) + 
  geom_density(alpha = 0.5)

ggplot(postDist_comparison, aes(x = b_x, colour = Approach, fill = Approach)) + 
  geom_density(alpha = 0.5)
```

The plots above show that the posterior distributions are quite similar. Next, let's see whether the Bayes factors are similar.

# Comparing Bayes factors
```{r}
m_data1_bf         <- hypothesis(m_data1, 'x = 0')$hypothesis$Evid.Ratio
m_data2_bf         <- hypothesis(m_data2, 'x = 0')$hypothesis$Evid.Ratio
m_data_combined_bf <- hypothesis(m_data_combined, 'x = 0')$hypothesis$Evid.Ratio

BF01  <- data.frame(Approach = c('sequential', 'combined'),
                    data1    = c(m_data1_bf, ''),
                    data2    = c(m_data2_bf, ''),
                    combined = c(m_data1_bf*m_data2_bf, m_data_combined_bf))
kable(BF01)
```

The BF01 (BF10 = `r 1/(m_data1_bf*m_data2_bf)` vs. `r 1/m_data_combined_bf`) are also very similar. 