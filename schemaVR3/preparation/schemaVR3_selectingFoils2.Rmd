---
title: "Selecting foils for schemaVR3: Attempt 2"
author: "JÃ¶rn Alexander Quent"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 6
    theme: united
---

```{r setup, include=FALSE}
# Libraries
library(ggplot2)
library(knitr)

# Settings
opts_knit$set(eval.after = 'fig.cap')
opts_chunk$set(echo = TRUE,
               warning = FALSE, 
               message = FALSE,
               fig.width = 10, 
               fig.height= 7,
               dpi=300, 
               out.width="1200px",
               out.height="700px")
options(scipen = 30)

```

# Aim of this document
This is the second attempt of selecting the foils for schemaVR3 ([click here to see first one](https://jaquent.github.io/2018/1102_schemaVR3_selectingFoils.html)). Unfortunately, there were mistake in the previous document as well as in the VR experiment, so that I had to discard two participant as pilot runs because the 3AFC task used different correct location than the 3D location recall task in VR. 

In a separate step, I selected five sets for schemaVR3 ([click here](https://jaquent.github.io/2018/0917_schemaVR3_stimulusSelection.html)). However, I did not select foil along side target locations because we originally planned to drop the 3AFC but now we decided to keep it in ([click here to see discussion](https://jaquent.me/2018/10/21/2018-10-18-finalising-analysis-and-design/)). 

In this document, I  will  therefore select foil locations for the pre-selected sets. 

# Preparation
As previously, I sample foil locations and check whether any foil or target location are the same for an object. This is repeated until I get the intended number valid runs. Then I calculate the sum of the squared differences and select the foils with the smallest values for each set separately. 

```{r preparation, eval = FALSE}
###############################################################
# Functions
convertSeconds <- function(seconds){
  seconds <- round(seconds)
  if(seconds < 60){
    # Less than a minute
    time    <- paste(round(seconds), 'sec')
  } 
  if(seconds >= 60 & seconds < 3600){
    # Less than an hour
    minutes <- (seconds - seconds %% 60)/60
    seconds <- seconds %% 60
    time    <- paste(minutes, 'min,', round(seconds), 'sec')
  } 
  if(seconds >= 3600 & seconds < 86400){
    # Less than a day
    hours   <-  (seconds - seconds %% 3600)/3600
    minutes <-  ((seconds %% 3600) - (seconds %% 3600) %% 60)/60
    seconds <-  (seconds %% 3600) %% 60
    time    <- paste(hours, 'h,', minutes, 'min,', round(seconds), 'sec')
  } 
  if(seconds >= 86400){
    # More than a day
    days    <- (seconds - seconds %% 86400)/86400
    hours   <- ((seconds %% 86400) - (seconds %% 86400) %% 3600)/3600
    minutes <- (((seconds %% 86400) %% 3600) - ((seconds %% 86400) %% 3600) %% 60)/60
    seconds <- ((seconds %% 86400) %% 3600) %% 60
    time    <- paste(days, 'd, ', hours, 'h,', minutes, 'min,', round(seconds), 'sec')
  }
  return(time)
}

progressDisplay <- function(i, iterations, startTime){
  startTime     <- as.numeric(startTime)
  currentTime   <- as.numeric(Sys.time())
  elapsedTime   <- currentTime - startTime
  predictedTime <- elapsedTime * (1/(i/iterations))
  cat('\rProgress: |',rep('=',floor((i/iterations)*50)),rep(' ',50 - floor((i/iterations)*50)),'|',
      '\tElapsed time:', convertSeconds(elapsedTime),
      '\tTotal time:',    convertSeconds(predictedTime), '\t\t',
      sep = '')
}

# Pre-selected sets
set.seed(422)
setNum <- c(848, 498, 388, 246, 111)
sets   <- read.csv("schemaVR3_sets.csv")

# Loading normative data
subNo                <- 1:6
N                    <- length(subNo)
numberObjects        <- 20
kitchenOjects        <- 1:12
numberKitchenObjects <- length(kitchenOjects)
nonKitchenObjets     <- 13:30
locationRatings      <- array(data = NA, dim = c(numberObjects, numberObjects, N))

# Sequently loading data
for(i in 1:N){
  locationRatings[,,i] <- matrix(scan(paste('/home/aq01/Projects/schemaVR/schemaVR3/preparation/schemaVR3_stimulusSelection/data/locationRatings_', as.character(subNo[i]) ,'.dat', sep = '')), byrow = TRUE, ncol = 20)
  #locationRatings[,,i] <- matrix(scan(paste('U:/Projects/schemaVR/schemaVR3/preparation/schemaVR3_stimulusSelection/data/locationRatings_', as.character(subNo[i]) ,'.dat', sep = '')), byrow = TRUE, ncol = 20)
}

# Calculating ranks
rankedRatings <- array(data = NA, 
                       dim = c(numberObjects, numberObjects, N))

for(i in 1:N){
  rankedRatings[,,i] <- rank(locationRatings[,,i])
}

# Calculating mean rank per object/ location
meanRankedRatings <- apply(rankedRatings, 1:2, mean)

iterations      <- 10000
numSets         <- length(setNum)
totalIterations <- iterations*numSets
foils1          <- array(data = NA, dim = c(numSets, iterations, numberObjects))
foils2          <- array(data = NA, dim = c(numSets, iterations, numberObjects))
SS_foils        <- array(data = NA, dim = c(numSets, iterations))

startTime <- Sys.time()
index     <- 0
for(i in 1: numSets){
  for(j in 1:iterations){
    foils1[i, j,]  <- sample(numberObjects)
    foils2[i, j,]  <- sample(numberObjects)
    while(any(foils1[i, j,]  == foils2[i, j,], sets[i + 1] == foils1[i, j,], sets[i + 1] == foils2[i, j,])){
      foils1[i, j,]  <- sample(numberObjects)
      foils2[i, j,]  <- sample(numberObjects)
    }
    SS_foils[i, j] <- sum((meanRankedRatings[cbind(seq_along(as.numeric(unlist(sets[i + 1]))),  as.numeric(unlist(sets[i + 1])))] - meanRankedRatings[cbind(seq_along(foils1[i, j,]),  foils1[i, j,])])^2, 
                          (meanRankedRatings[cbind(seq_along(as.numeric(unlist(sets[i + 1]))),  as.numeric(unlist(sets[i + 1])))] - meanRankedRatings[cbind(seq_along(foils2[i, j,]), foils2[i, j,])])^2)
    
    index <- index + 1
    progressDisplay(index, totalIterations, startTime)
  }
}

save.image(paste('data_selectingFoils_',format(Sys.time(), "%Y%m%d_%H%M"), '.RData', sep = ""))
```

# Selecting and checking foils
```{r selectingFoils}
# Loading data
load('data_selectingFoils_20181107_0537.RData')
objNam <- sets$Objects

# Visualising data
SS_foils_DF <- data.frame(set = rep(setNum, each = dim(SS_foils)[2]),
                          SS  = c(SS_foils))

# Displaying distributions
ggplot(SS_foils_DF, aes(SS)) + 
  facet_grid(~ set) +
  geom_histogram(binwidth = 100) + 
  theme(panel.margin = unit(2, "cm"), 
        text = element_text(size = 12),  
        plot.margin = margin(10, 10, 10, 10)) + 
  labs(y = 'Number of occurences', 
       x = 'Sum of squared differences', 
       title = paste('Distribution of SS of targets N =', iterations)) + 
  coord_cartesian(expand = FALSE)
```

As can be seen above the SS distribution for the different sets look similar. In the next step, I am select the foils with the smallest SS value and check their spread. 

```{r}
# Getting min values and selecting sets
minValues <- apply(SS_foils, 1, min)
finalSets <- data.frame(set = rep(setNum, each = numberObjects),
                        objNum = rep(1:20, 5),
                        objNam = rep(objNam, 5),
                        target = c(sets$Set1, sets$Set2, sets$Set3, sets$Set4, sets$Set5),
                        foils1  = c(foils1[1, which(SS_foils[1,] == minValues[1]), ], 
                                    foils1[2, which(SS_foils[2,] == minValues[2]), ],
                                    foils1[3, which(SS_foils[3,] == minValues[3]), ],
                                    foils1[4, which(SS_foils[4,] == minValues[4]), ],
                                    foils1[5, which(SS_foils[5,] == minValues[5]), ]),
                        foils2  = c(foils2[1, which(SS_foils[1,] == minValues[1]), ], 
                                    foils2[2, which(SS_foils[2,] == minValues[2]), ],
                                    foils2[3, which(SS_foils[3,] == minValues[3]), ],
                                    foils2[4, which(SS_foils[4,] == minValues[4]), ],
                                    foils2[5, which(SS_foils[5,] == minValues[5]), ]))

# In the previos document I forgot to change the index of foils1 from foils1[1, min, ] to foils1[1, min, ], foils1[2, min, ]...

finalSets$targetExp <- meanRankedRatings[cbind(rep(1:20, 5),  finalSets$target)]
finalSets$foils1Exp <- meanRankedRatings[cbind(rep(1:20, 5),  finalSets$foils1)]
finalSets$foils2Exp <- meanRankedRatings[cbind(rep(1:20, 5),  finalSets$foils2)]


# Visualise spread of individual sets
spreadData <- data.frame(set  = rep(finalSets$set, 3),
                         objNum = rep(1:20, 5*3),
                         location = c(finalSets$target, finalSets$foils1, finalSets$foils2),
                         type = rep(c('target', 'foil1','foil2'), each = numberObjects*5),
                         exp  = c(finalSets$targetExp, finalSets$foils1Exp, finalSets$foils2Exp))

ggplot(spreadData, aes(x = type, y = exp)) +
  facet_grid(~ set) +
  geom_point() +
  theme(panel.margin = unit(2, "cm"), 
        text = element_text(size = 12),  
        plot.margin = margin(10, 10, 10, 10)) + 
  labs(y = 'Normative Expectancy')
  
```

To ensure that the foil location are not systematically different from the target locations, I visualise them above, which give a satisfying result. Below the final selection can be found:

```{r finalSelection}
# Final selection
kable(finalSets)
```

Next I will create the input files for the two computer tasks. 

## Creating input files for 3AFC task
```{r creatingFilesAFC}
# Create .txt file with columns: objectNumber, foil1Rank, encodingRank, foil2Rank, foil1Location, encodingLocation, foil2Location
fileName <- 'inputFiles_3AFC/schemaVR3_3AFC_inputFile_'

# Loop for each set one file
for(i in setNum){
  tempData <- data.frame(objNum = 1:20,
                         foil1Rank = subset(finalSets, set == i)$foils1Exp,
                         encodingRank = subset(finalSets, set == i)$targetExp,
                         foil2Rank = subset(finalSets, set == i)$foils2Exp,
                         foil1Location = subset(finalSets, set == i)$foils1,
                         encodingLocation = subset(finalSets, set == i)$target,
                         foil2Location = subset(finalSets, set == i)$foils2)
  write.table(tempData,
              paste(fileName, i, '.txt', sep = ''),
              row.names = FALSE,
              col.names = FALSE,
              quote = FALSE,
              sep = '\t')
}
```

## Creating input files for rating task
```{r creatingFilesRating}
# Creating input file for object/location rating task
objNam   <- c('is this microwave',
              'is this kitchen roll',
              'is this saucepan',
              'is this toaster',
              'is this bowl of fruits ',
              'is this tea pot',
              'is this knife',
              'is this mixer ',
              'is this bread',
              'is this glass jug',
              'is this mug',
              'are these dishes',
              'are these towels',
              'is this toy',
              'is this pile of books',
              'is this umbrella',
              'is this hat',
              'is this helmet',
              'is this calendar',
              'is this fan')

string1 <- 'How expected'
string2 <- 'in that location?'

# Loop to create the .txt files: picture name (objNum_Location), questions
for(i in setNum){
  subData  <- subset(spreadData, set == i)
  tempData <- data.frame(imgNam = paste(subData$objNum, '_', subData$location, sep = ''),
                         question = paste(string1, objNam[subData$objNum], string2))
  write.table(tempData, 
        paste('inputFiles_rating/questionsObjectLocation_', i, '.txt', sep = ''),
        row.names = FALSE,
        col.names = FALSE,
        quote = FALSE, 
        sep = '\t')
}
```