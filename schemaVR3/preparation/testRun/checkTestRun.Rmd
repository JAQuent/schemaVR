---
title: "Checking test run data"
author: "JÃ¶rn Alexander Quent"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 6
    theme: united
---
```{r setup, include=FALSE}
knitr::opts_knit$set(eval.after = 'fig.cap')
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE, 
                      message = FALSE,
                      fig.width = 10, 
                      fig.height= 7, 
                      dpi=300, 
                      out.width="1200px", 
                      out.height="700px")
options(scipen = 30)

# Libaries
library(data.table)
library(plyr)
library("plot3D")
library(car)
```

# Aim of this document
Before I start running schemaVR3 next week. I check whether the data is saved correctly. I did this by completing the experiment myself for all five sets. I noted every response I gave and made sure that I place every object correctly to make sure that perfect spatial memory is reflected in an accuracy of 100 %. 

# Recall data
## Lodaing data
```{r loadingRecallData}
subNum   <- 1:5
setNum   <- c(111, 246, 388, 498, 848)
fileNam1 <- 'schemaVR3_recall_'
fileNam2 <- 'correctionValues_'
fileNam3 <- 'schemaVR3_encodingInputFile_VR_'
fileNam4 <- 'schemaVR3_3AFC_inputFile_'
colNam  <- c('subNum',
             'trial',
             'set',
             'startTime',
             'pickUpTime',
             'dropDownTime',
             'objNam',
             'objNum',
             'respTime',
             'answerTime',
             'numAttempts',
             'memory',
             'xPlaced',
             'yPlaced',
             'zPlaced')

# Loading all files and combining it to a data set
for(i in subNum){
  # Loading files
  tempData        <- read.table(paste(fileNam1, i,'.txt', sep = ''))
  names(tempData) <- colNam
  correVal        <- read.table(paste(fileNam2, i,'.txt', sep = ''))
  encodLoc        <- read.table(paste(fileNam3, tempData$set[1],'.txt', sep = ''))
  
  # Adding the number of the correct location to data set
  AFC_input         <- read.table(paste(fileNam4, tempData$set[1],'.txt', sep = ''))
  tempData$encodLoc <- AFC_input[tempData$objNum, 6]
  
  # Correcting X and Z values based on saved values from experiments
  encodLoc$V5     <- encodLoc$V5 - correVal$V1
  encodLoc$V7     <- encodLoc$V7 - correVal$V2
  names(encodLoc) <- c('objName', 
                       'xRot', 
                       'yRot', 
                       'zRot', 
                       'xPos', 
                       'yPos', 
                       'zPos')
                                 
  # Adding correct/encoding locations to the dataset.
  tempData$objNam          <- as.factor(tempData$objNam)
  tempData$xPosCorr  <- NA_real_
  tempData$yPosCorr  <- NA_real_
  tempData$zPosCorr  <- NA_real_
  for(j in levels(tempData$objNam)){
    # Going through all objects and assign the correct location. By looking for it based on the object name
    tempData[which(tempData$objNam == j), 'xPosCorr'] <- encodLoc[which(encodLoc$objNam == j), 'xPos']
    tempData[which(tempData$objNam == j), 'yPosCorr'] <- encodLoc[which(encodLoc$objNam == j), 'yPos']
    tempData[which(tempData$objNam == j), 'zPosCorr'] <- encodLoc[which(encodLoc$objNam == j), 'zPos']
    
  }
  
  # Bind to data frame or create new file 
  if(exists('dataRecall')){
    dataRecall <- rbind(dataRecall, tempData)
  } else {
    dataRecall <- tempData
  }
}
```

## Checking data
```{r checkingRecallData}
euclideanDistance3D <-function(x1, y1, z1, x2, y2, z2){
  return(sqrt((x1 - x2)^2 + (y1 - y2)^2 + (z1 - z2)^2))
} # This function is used to calculate the Euclidean distance in 3D space

# Calculating Euclidean distance between participants' placements and the correct location.
dataRecall$euclideanDist <- euclideanDistance3D(dataRecall$xPlaced, 
                                                dataRecall$yPlaced, 
                                                dataRecall$zPlaced, 
                                                dataRecall$xPosCorr, 
                                                dataRecall$yPosCorr, 
                                                dataRecall$zPosCorr)

######################################################################################
# Calculating recall accuracy.
# This is calculated by finding the closest spawnPoint and then checking whether it was the correct one. 
dataRecall$accRecall  <- NA
dataRecall$closestLoc <- NA
dataRecall$next2Loc   <- NA
dataRecall$next3Loc   <- NA
dataRecall$next4Loc   <- NA
dataRecall$next5Loc   <- NA
dataRecall$next6Loc   <- NA
dataRecall$next7Loc   <- NA
dataRecall$next8Loc   <- NA
dataRecall$next9Loc   <- NA
dataRecall$next10Loc  <- NA
dataRecall$next11Loc  <- NA
dataRecall$next12Loc  <- NA
dataRecall$next13Loc  <- NA
dataRecall$next14Loc  <- NA
dataRecall$next15Loc  <- NA
dataRecall$next16Loc  <- NA
dataRecall$next17Loc  <- NA
dataRecall$next18Loc  <- NA
dataRecall$next19Loc  <- NA
dataRecall$next20Loc  <- NA
for(i in 1:dim(dataRecall)[1]){
  if(!is.na(dataRecall$xPlaced[i])){
    # If the values are not NA.
    # Calculating Euclidea distance between participants' placement and all twenty locations (i.e. spawn points).
    tempData    <- subset(dataRecall, subNum == dataRecall$subNum[i])
    spawnPoints <-  data.frame(point = tempData$encodLoc, 
                               x = tempData$xPosCor,
                               y = tempData$yPosCor,
                               z = tempData$zPosCor)
    distances             <- euclideanDistance3D(dataRecall$xPlaced[i],
                                                 dataRecall$yPlaced[i],
                                                 dataRecall$zPlaced[i],
                                                 spawnPoints$x,
                                                 spawnPoints$y,
                                                 spawnPoints$z)
    
    # Saving the closest spawn point as well as the second, third and so on closet spawn point.
    dataRecall$closestLoc[i] <- as.numeric(spawnPoints[order(distances)[1], 1])
    dataRecall$next2Loc[i]   <- as.numeric(spawnPoints[order(distances)[2], 1])
    dataRecall$next3Loc[i]   <- as.numeric(spawnPoints[order(distances)[3], 1])
    dataRecall$next4Loc[i]   <- as.numeric(spawnPoints[order(distances)[4], 1])
    dataRecall$next5Loc[i]   <- as.numeric(spawnPoints[order(distances)[5], 1])
    dataRecall$next6Loc[i]   <- as.numeric(spawnPoints[order(distances)[6], 1])
    dataRecall$next7Loc[i]   <- as.numeric(spawnPoints[order(distances)[7], 1])
    dataRecall$next8Loc[i]   <- as.numeric(spawnPoints[order(distances)[8], 1])
    dataRecall$next9Loc[i]   <- as.numeric(spawnPoints[order(distances)[9], 1])
    dataRecall$next10Loc[i]  <- as.numeric(spawnPoints[order(distances)[10], 1])
    dataRecall$next11Loc[i]  <- as.numeric(spawnPoints[order(distances)[11], 1])
    dataRecall$next12Loc[i]  <- as.numeric(spawnPoints[order(distances)[12], 1])
    dataRecall$next13Loc[i]  <- as.numeric(spawnPoints[order(distances)[13], 1])
    dataRecall$next14Loc[i]  <- as.numeric(spawnPoints[order(distances)[14], 1])
    dataRecall$next15Loc[i]  <- as.numeric(spawnPoints[order(distances)[15], 1])
    dataRecall$next16Loc[i]  <- as.numeric(spawnPoints[order(distances)[16], 1])
    dataRecall$next17Loc[i]  <- as.numeric(spawnPoints[order(distances)[17], 1])
    dataRecall$next18Loc[i]  <- as.numeric(spawnPoints[order(distances)[18], 1])
    dataRecall$next19Loc[i]  <- as.numeric(spawnPoints[order(distances)[19], 1])
    dataRecall$next20Loc[i]  <- as.numeric(spawnPoints[order(distances)[20], 1])
    
    if(dataRecall$closestLoc[i] == dataRecall$encodLoc[i]){
      # If closest lcoation is target location.
      dataRecall$accRecall[i] <- 1
    } else {
      # If closet lcoation is not target location.
      dataRecall$accRecall[i] <- 0
    } 
  } else {
    # If the values are NA
    # Saving the closest spawn point as well as the second, third and so on closet spawn point
    dataRecall$closestLoc[i] <- NA
    dataRecall$accRecall[i]  <- NA
    dataRecall$next2Loc[i]   <- NA
    dataRecall$next3Loc[i]   <- NA
    dataRecall$next4Loc[i]   <- NA
    dataRecall$next5Loc[i]   <- NA
    dataRecall$next6Loc[i]   <- NA
    dataRecall$next7Loc[i]   <- NA
    dataRecall$next8Loc[i]   <- NA
    dataRecall$next9Loc[i]   <- NA
    dataRecall$next10Loc[i]  <- NA
    dataRecall$next11Loc[i]  <- NA
    dataRecall$next12Loc[i]  <- NA
    dataRecall$next13Loc[i]  <- NA
    dataRecall$next14Loc[i]  <- NA
    dataRecall$next15Loc[i]  <- NA
    dataRecall$next16Loc[i]  <- NA
    dataRecall$next17Loc[i]  <- NA
    dataRecall$next18Loc[i]  <- NA
    dataRecall$next19Loc[i]  <- NA
    dataRecall$next20Loc[i]  <- NA
  }
}

# Exluciding trials where I couldn't place object
dataRecallsub <- subset(dataRecall, !(dataRecall$subNum == 1 & dataRecall$objNam == 'teaPot') &
                                    !(dataRecall$subNum == 1 & dataRecall$objNam == 'helmet') &
                                    !(dataRecall$subNum == 1 & dataRecall$objNam == 'saucepan'))

dataRecallsub$accRecall
```

Luckily, the data is saved correctly and I get the expected `r mean(dataRecallsub$accRecall)*100` % accuracy. This is quite important to know because of the way I calculate recall accuracy. 

# Tracking data
For schemaVR3, I also track the participants movement and rotation. Currently, I don't have any specific plan to analyse it though. Nevertheless, I wanted to check whether it worked. 

```{r checkingTrackingData}
# Loading file
tracking <- read.table("trackingData_retrieval_1.txt", sep = '\t')
names(tracking) <- c('Obj', 
                     'ObjID', 
                     'Time', 
                     'xPos',
                     'yPos',
                     'zPos',
                     'xRot',
                     'yRot',
                     'zRot')

# Subsetting to only show tracking of camera (i.e. head position).
trackingPlayer <- subset(tracking, 
                         Obj == levels(tracking$Obj)[1])

# 2D line plot to display tracking data
plot(trackingPlayer$xPos, 
     trackingPlayer$zPos, 
     type = 'l',
     xlab = 'X',
     ylab = 'Z')

# 3D line plot to display tracking data
lines3D(trackingPlayer$xPos, 
        trackingPlayer$zPos, 
        trackingPlayer$yPos, 
        xlab = 'x',
        ylab = 'z',
        zlab = 'y')
```