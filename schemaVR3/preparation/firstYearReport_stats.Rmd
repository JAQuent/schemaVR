---
title: 'First year report: Effect of schema on object/location memory in VR'
author: "Joern Alexander Quent"
date: "June 25, 2018"
output:
  html_document:
    theme: united
    toc: yes
    toc_depth: 6
  pdf_document:
    toc: yes
    toc_depth: '6'
  word_document:
    toc: yes
    toc_depth: '6'
fontsize: 12pt
geometry: left=2.54cm,right=2.54cm,top=2.54cm,bottom=2.54cm
---

```{r setup, include=FALSE}
options(scipen = 30)

# Libraries
library(plyr)
library(data.table)
library(knitr)
library(lmerTest)
library(ggplot2)
library(gridExtra)
library(grid)

# Settings
opts_chunk$set(echo = TRUE,
               warning = FALSE,
               message = FALSE,
               eval = TRUE,                     
               fig.width = 10, 
               fig.height = 7, 
               dpi = 300)
opts_knit$set(eval.after = 'fig.cap')

# Functions
pValue <-function(x, sign = '='){
  if (inherits(x, "lm")){
    s <- summary.lm(x)
    x <- pf(s$fstatistic[1L], s$fstatistic[2L], s$fstatistic[3L], lower.tail = FALSE)
    if(x > 1){
      stop("There is no p-value greater than 1")
    } else if(x > 0){
      stop("There is no p-value smaller than 0")
    } else if(x < 0.001){
      x.converted <- '< .001'
    } else{
      x.converted <- paste(sign,substr(as.character(round(x, 3)), 2,5))
    } 
  } else {
    if(x > 1){
      stop("There is no p-value greater than 1")
    } else if(x < 0.001){
      x.converted <- '< .001'
    } else{
      x.converted <- paste(sign,substr(as.character(round(x, 3)), 2,5))
    } 
  }
  return(x.converted)
}

rValue <-function(x){
  if (inherits(x, "lm")){
    r.squared <- summary(x)$r.squared
    x.converted <- paste('=',substr(as.character(round(r.squared, 3)), 2,5)) 
  } else {
    if (x < 0){
      x.converted <- paste('= -',substr(as.character(abs(round(x, 3))), 2,5), sep = '') 
    } else {
      x.converted <- paste('=',substr(as.character(abs(round(x, 3))), 2,5)) 
    }
  }
  return(x.converted) 
}

num2word <- function(x){
  # Checking whether number if integer
  if(x%%1 != 0){
    stop('Number is not in integer')
  } else {
    if(x == 0){out <- 'zero'} 
    else if(x == 1){out  <- 'one'} 
    else if(x == 2){out  <- 'two'} 
    else if(x == 3){out  <- 'three'} 
    else if(x == 4){out  <- 'four'} 
    else if(x == 5){out  <- 'five'} 
    else if(x == 6){out  <- 'six'} 
    else if(x == 7){out  <- 'seven'} 
    else if(x == 8){out  <- 'eight'} 
    else if(x == 9){out  <- 'nine'} 
    else if(x == 10){out <- 'ten'} 
    else if(x == 11){out <- 'eleven'} 
    else if(x == 12){out <- 'twelve'} 
    else if(x == 13){out <- 'thirteen'} 
    else if(x == 14){out <- 'fourteen'} 
    else if(x == 15){out <- 'fifteen'} 
    else if(x == 16){out <- 'sixteen'} 
    else if(x == 17){out <- 'seventeen'} 
    else if(x == 18){out <- 'eighteen'} 
    else if(x == 19){out <- 'nineteen'} 
    else if(x == 20){out <- 'twenty'} 
    else if(x >  20){out <- x}
  }
  return(out)
}

firstUp <- function(x){
  # From https://stackoverflow.com/questions/18509527/first-letter-to-upper-case
   substr(x, 1, 1) <- toupper(substr(x, 1, 1))
x
}

sigStars <- function(x){
  # Adding stars to indicate significance
  stars <- rep("", length(x))
  stars[x <= 0.1   & x > 0.05]   <- '.' # trend
  stars[x <= 0.05  & x > 0.01]   <- '*'
  stars[x <= 0.01  & x > 0.001]  <- '**'
  stars[x <= 0.001]              <- '***'
  return(stars)
}

createResultTable <- function(x){
  # Creating a nice looking table
  if(inherits(x, "glmerMod")){
    # For glmer table
    xTable        <- summary(x)$coefficients
    xTable        <- data.frame(xTable)
    xTable[, 1]   <- round(xTable[, 1], 2)
    xTable[, 2]   <- round(xTable[, 2], 2)
    xTable[, 3]   <- round(xTable[, 3], 2)
    xTable[, 4]   <- round(xTable[, 4], 4)
    xTable        <- cbind(xTable, sigStars(xTable[, 4]))
    names(xTable) <- c('Estimate', 'SE', 'Z', 'P', 'Sig')
  } else if(inherits(x, 'lmerModLmerTest')){
    xTable        <- summary(x)$coefficients
    xTable        <- data.frame(xTable)
    xTable[, 1]   <- round(xTable[, 1], 2)
    xTable[, 2]   <- round(xTable[, 2], 2)
    xTable[, 3]   <- round(xTable[, 3], 2)
    xTable[, 4]   <- round(xTable[, 4], 2)
    xTable[, 5]   <- round(xTable[, 5], 4)
    xTable        <- cbind(xTable, sigStars(xTable[, 5]))
    names(xTable) <- c('Estimate', 'SE', 'DF', 'T', 'P', 'Sig')
  } else if(inherits(x, 'anova')){
    if(attributes(x)$heading == "Analysis of Variance Table of type III  with  Satterthwaite \napproximation for degrees of freedom"){
      # Only ANOVA on lmerTest models with Satterthwaite approximation
      xTable        <- data.frame(x)
      xTable[, 1]   <- round(xTable[, 1], 2)
      xTable[, 2]   <- round(xTable[, 2], 2)
      xTable[, 3]   <- round(xTable[, 3], 2)
      xTable[, 4]   <- round(xTable[, 4], 2)
      xTable[, 5]   <- round(xTable[, 5], 2)
      xTable[, 6]   <- round(xTable[, 6], 4)
      xTable        <- cbind(xTable, sigStars(xTable[, 6]))
      names(xTable) <- c('SS', 'MSS', 'nDF', 'dDF', 'F', 'P', 'Sig') 
    } else {
      xTable <- data.frame('######', 'No known model', '######')
      names(xTable) <- c('%%%', '***', '&&&')
    }
  } else {
    xTable <- data.frame('######', 'No known model', '######')
    names(xTable) <- c('%%%', '***', '&&&')
  }
  return(xTable)
}

madOutlier <- function(x){
  # Based on Leys, C., Ley, C., Klein, O., Bernard, P., & Licata, L. (2013). 
  # Detecting outliers: Do not use standard deviation around the mean, use 
  # absolute deviation around the median. Journal of Experimental Social 
  # Psychology, 49(4), 764â€“766. https://doi.org/10.1016/j.jesp.2013.03.013
  return((x - median(x, na.rm = TRUE))/mad(x, na.rm = TRUE))
}

logit2prob <- function(logit){
  # Source: https://sebastiansauer.github.io/convert_logit2prob/ 
  odds <- exp(logit)
  prob <- odds / (1 + odds)
  return(prob)
}

# Variables
objNames  <- c('microwave *',
               'kitchen roll *',
               'saucepan *', 
               'toaster *',
               'bowl of fruits *',
               'tea pot *',
               'knife',
               'mixer',
               'bread',
               'glass jug',
               'mug',
               'dishes',
               'towels *',
               'toy *',
               'pile of books *',
               'umbrella *',
               'hat *',
               'helmet',
               'calendar',
               'fan')
```

# Introduction


# Experiment 1
```{r}
# Loading 
load("U:/Projects/schemaVR/report_firstYear/report/data/exp1Data.RData")
dataSchemaVR1 <- combData
rm(combData)

#Add (non-)kitchen object factor to data
dataSchemaVR1$expectedInKitchen                                      <- 'non-kitchen'
dataSchemaVR1[which(dataSchemaVR1$objNum < 13), 'expectedInKitchen'] <- 'kitchen'
```

## Participants
```{r}
dataSchemaVR1Demo   <- ddply(dataSchemaVR1, 
                             c('subNum', 'gender'), 
                             summarise, 
                             age = mean(age))
table(dataSchemaVR1Demo$gender)

# Notes and decision on participants:
# Participant #1: Sligthly different instructions for no-memory trial -> exlcude.
# Participant #1 to #6: Had no familiarisation phase
# Participant #5 and # 15: Second exposure with stimulus -> include.
# Participant #9: No memory trials on trial 1 and 2 because I pressed those accidently -> changed.
dataSchemaVR1[which(dataSchemaVR1$subNum == 9 & (dataSchemaVR1$recallTrial == 1 | dataSchemaVR1$recallTrial == 2)), 'recallNoMemory'] <- 1
# Participant #10: Problems with data and from towel -> no anormalities.
# Participant #13: Had a longer delay (1.5 min)
dataSchemaVR1 <- subset(dataSchemaVR1, subNum != 1)
```


## Results
### Overall memory performance
```{r}
# Legend: 1 = Did not see object| 2 = Guess the object was there | 3 = Know the object was there
 table(dataSchemaVR1$resCon)


# Looking at no memory trials and confidence responses for each object
schemaVR1_table3 <- ddply(dataSchemaVR1, c('objName', 'objNum'), summarise, 
                noMemory = sum(recallNoMemory, na.rm = TRUE), 
                notSeen  = table(resCon)[1], 
                guessed  = table(resCon)[2], 
                knew     = table(resCon)[3])

cor.test(schemaVR1_table3$noMemory, schemaVR1_table3$notSeen, method = 'pearson')
```

```{r}
dataSchemaVR1_recallData      <- subset(dataSchemaVR1, dataSchemaVR1$recallNoMemory == 0 | is.na(dataSchemaVR1$recallNoMemory))
dataSchemaVR1_recallData_agg  <- ddply(dataSchemaVR1_recallData, 
                                       c('subNum'), 
                                       summarise, 
                                       accRecall = mean(accRecall, na.rm = TRUE))

dataSchemaVR1_afcData     <- subset(dataSchemaVR1, dataSchemaVR1$resCon != 1)
dataSchemaVR1_afcData_agg <- ddply(dataSchemaVR1, 
                                   c('subNum'), 
                                   summarise, 
                                   accAFC = mean(accAFC, na.rm = TRUE))

# Calculating tests
t.test(dataSchemaVR1_recallData_agg$accRecall - 1/20)
t.test(dataSchemaVR1_afcData_agg$accAFC - 1/3)
cor.test(dataSchemaVR1_recallData_agg$accRecall, dataSchemaVR1_afcData_agg$accAFC)
```


### Relationship between memory performance and expectancy
```{r}
# Adding the normative object/location rating for each target and foil 1 & 2
dataSchemaVR1$objLocTargetNorm <- NA
dataSchemaVR1$objLocFoil1Norm  <- NA
dataSchemaVR1$objLocFoil2Norm  <- NA
for(i in 1:dim(dataSchemaVR1)[1]){
  dataSchemaVR1$objLocTargetNorm[i] <- dataSchemaVR1[i, paste("loc", dataSchemaVR1$targetLocation[i], sep = "")]
  dataSchemaVR1$objLocFoil1Norm[i]  <- dataSchemaVR1[i, paste("loc", dataSchemaVR1$foil1Location[i], sep = "")]
  dataSchemaVR1$objLocFoil2Norm[i]  <- dataSchemaVR1[i, paste("loc", dataSchemaVR1$foil2Location[i], sep = "")]
}

# scaling data for analysis
dataSchemaVR1_Scaled                    <- dataSchemaVR1
dataSchemaVR1_Scaled$objLocTargetRating <- scale(dataSchemaVR1_Scaled$objLocTargetRating)
dataSchemaVR1_Scaled$targetRankPre      <- scale(dataSchemaVR1_Scaled$targetRankPre)
dataSchemaVR1_Scaled$generalRatingNorm  <- scale(dataSchemaVR1_Scaled$generalRatingNorm)
dataSchemaVR1_Scaled$generalRatingPost  <- scale(dataSchemaVR1_Scaled$generalRatingPost)
dataSchemaVR1_Scaled$objLocTargetNorm   <- scale(dataSchemaVR1_Scaled$objLocTargetNorm)
```

```{r}
# Subsetting data
dataSchemaVR1_recall <- subset(dataSchemaVR1_Scaled, dataSchemaVR1_Scaled$recallNoMemory == 0)

schemaVR1_model1_without <- glmer(accRecall ~  
                            objLocTargetRating + 
                            I(objLocTargetRating*objLocTargetRating) +
                            (1 | subNum) +
                            (1 | objNum), 
                          data = dataSchemaVR1_recall,
                          family = binomial,
                          control = glmerControl(optimizer = "bobyqa"),
                          nAGQ = 1)

createResultTable(schemaVR1_model1_without)

schemaVR1_model1_with <- glmer(accRecall ~  
                            objLocTargetRating + 
                            I(objLocTargetRating*objLocTargetRating) + 
                            generalRatingPost +
                            (1 | subNum), 
                          data = dataSchemaVR1_recall,
                          family = binomial,
                          control = glmerControl(optimizer = "bobyqa"),
                          nAGQ = 1)

createResultTable(schemaVR1_model1_with)
```


```{r}
schemaVR1_model3_with <- lmer(euclideanDist ~  objLocTargetRating + 
                                I(objLocTargetRating*objLocTargetRating) + 
                                generalRatingPost +
                                (1 | subNum) + 
                                (1 | objNum), 
                              data = dataSchemaVR1_recall)

createResultTable(schemaVR1_model3_with)

schemaVR1_model3_without <- lmer(euclideanDist ~  objLocTargetRating + 
                                   I(objLocTargetRating*objLocTargetRating) + 
                                   (1 | subNum) + 
                                   (1 | objNum), 
                                 data = dataSchemaVR1_recall)

createResultTable(schemaVR1_model3_without)
```


```{r}
# Subsetting data
dataSchemaVR1_AFC    <- subset(dataSchemaVR1_Scaled, dataSchemaVR1_Scaled$resCon != 1)

schemaVR1_model2_with <- glmer(accAFC ~  objLocTargetRating + 
                            I(objLocTargetRating*objLocTargetRating) + 
                            generalRatingPost +
                            (1 | subNum) +
                            (1 | objNum), 
                          data = dataSchemaVR1_AFC,
                          family = binomial,
                          control = glmerControl(optimizer = "bobyqa"),
                          nAGQ = 1)

createResultTable(schemaVR1_model2_with)


schemaVR1_model2_without <- glmer(accAFC ~  objLocTargetRating + 
                            I(objLocTargetRating*objLocTargetRating) +
                            (1 | subNum) +
                            (1 | objNum), 
                          data = dataSchemaVR1_AFC,
                          family = binomial,
                          control = glmerControl(optimizer = "bobyqa"),
                          nAGQ = 1)

createResultTable(schemaVR1_model2_without)
```

### Recall bias
```{r}
# Finding the expectancy of the closest location for an object
dataSchemaVR1$closestObjLocNorm <- NA
# Add normative location rating
for(i in 1:dim(dataSchemaVR1)[1]){
  if(!is.na(dataSchemaVR1$closestLoc[i])){
    # Necessary to use if statement because some values are NA and cannot be used to index
   dataSchemaVR1$closestObjLocNorm[i] <- dataSchemaVR1[i, paste("loc", dataSchemaVR1$closestLoc[i], sep = "")] 
  }
}

schemaVR1_recallBias_data <- ddply(subset(dataSchemaVR1, recallNoMemory == 0 & !is.na(dataSchemaVR1$accRecall)),
                                   c('subNum', 'accRecall'),
                                   summarise, 
                                   closestObjLocNorm = mean(closestObjLocNorm, na.rm = TRUE))

schemaVR1_recallBias     <- ddply(schemaVR1_recallBias_data, 
                                  c('accRecall'),
                                  summarise, 
                                  mean = mean(closestObjLocNorm, na.rm = TRUE),
                                  sd = sd(closestObjLocNorm, na.rm = TRUE))
t.test(closestObjLocNorm ~ accRecall, schemaVR1_recallBias_data, paired = TRUE)
```


# Experiment 2
```{r}
# Loading 
load("U:/Projects/schemaVR/report_firstYear/report/data/exp2Data.RData")
dataSchemaVR2 <- combData
rm(combData)

#Add (non-)kitchen object factor to data
dataSchemaVR2$expectedInKitchen                                      <- 'non-kitchen'
dataSchemaVR2[which(dataSchemaVR2$objNum < 13), 'expectedInKitchen'] <- 'kitchen'
```


## Participants
```{r}
dataSchemaVR2Demo   <- ddply(dataSchemaVR2, 
                             c('subNum', 'gender'), 
                             summarise, 
                             age = mean(age))
table(dataSchemaVR2Demo$gender)

# Notes and decision on participants:
# Participant #20 to #24: Exclude participants because they did the  wrong objLocTargetRating
dataSchemaVR2 <- subset(dataSchemaVR2, subNum >= 25)
# Participant #20 to #27: Foil2 for umbrella was not saved.
# Participant #25 to #27: Rated object 16 at location 1 instead of 14. This value is therefore missing.
# Participant #22: Seen objects twice but is excluded anyway. 
# Participant #26: Check recall microwave because it was correct (it is). The 2nd rating was 100 not 0.
dataSchemaVR2[which(dataSchemaVR2$subNum == 26 & dataSchemaVR2$objNum == 3), 'generalRatingPost'] <- 100
```





## Results
### Overall memory performance
The average number of remember, familiar, guess and no memory responses per participant is shown in Table 2.

```{r}
# Response given for judgement (0 = no memory, 1 = remember, 2 = familiar, 3 = guess)
dataSchemaVR2$recallMemory[which(dataSchemaVR2$recallMemory == -1)] <- NA # Code missing value

# Looking at no memory trials and confidence responses for each object
schemaVR2_table1 <- ddply(dataSchemaVR2, 
                          c('subNum'), 
                          summarise,
                          RecallNoMemory     = table(recallMemory)[1],
                          RecallRecollection = table(recallMemory)[2],
                          RecallFamiliarity  = table(recallMemory)[3],
                          RecallGuess        = table(recallMemory)[4],
                          AFCNoMemory        = table(resCon)[1], 
                          AFCRecollection    = table(resCon)[2],
                          AFCFamiliarity     = table(resCon)[3],
                          AFCGuess           = table(resCon)[4])


RecallMean <- round(c(mean(schemaVR2_table1$RecallRecollection, na.rm = TRUE),
                      mean(schemaVR2_table1$RecallFamiliarity, na.rm = TRUE),
                      mean(schemaVR2_table1$RecallGuess, na.rm = TRUE),
                      mean(schemaVR2_table1$RecallGuess, na.rm = TRUE)), 2)

RecallSD <- round(c(sd(schemaVR2_table1$RecallRecollection, na.rm = TRUE),
                    sd(schemaVR2_table1$RecallFamiliarity, na.rm = TRUE),
                    sd(schemaVR2_table1$RecallGuess, na.rm = TRUE),
                    sd(schemaVR2_table1$RecallGuess, na.rm = TRUE)), 2)

afcMean <- round(c(mean(schemaVR2_table1$AFCRecollection, na.rm = TRUE),
                   mean(schemaVR2_table1$AFCFamiliarity, na.rm = TRUE),
                   mean(schemaVR2_table1$AFCGuess, na.rm = TRUE),
                   mean(schemaVR2_table1$AFCNoMemory, na.rm = TRUE)), 2)

afcSD <- round(c(sd(schemaVR2_table1$AFCRecollection, na.rm = TRUE),
                 sd(schemaVR2_table1$AFCFamiliarity, na.rm = TRUE),
                 sd(schemaVR2_table1$AFCGuess, na.rm = TRUE),
                 sd(schemaVR2_table1$AFCNoMemory, na.rm = TRUE)), 2)


schemaVR2_table1 <- data.frame(Response = c('Remember', 
                                            'Familiar', 
                                            'Guess',
                                            'No memory'),
                               Recall = paste(RecallMean, ' (', RecallSD, ')', sep = ''),
                               AFC    = paste(afcMean, ' (', afcSD, ')', sep = ''))
names(schemaVR2_table1) <- c('Response', 'Recall', '3AFC')


kable(schemaVR2_table1, caption = 'Average number of each type of memory judgement across both tasks with SD in brackets.')
```

```{r}
dataSchemaVR2_recallData      <- subset(dataSchemaVR2, dataSchemaVR2$recallMemory != 0 | !is.na(dataSchemaVR2$recallMemory))
dataSchemaVR2_recallData_agg  <- ddply(dataSchemaVR2_recallData, 
                                       c('subNum'), 
                                       summarise, 
                                       accRecall = mean(accRecall, na.rm = TRUE))

dataSchemaVR2_afcData     <- subset(dataSchemaVR2, resCon != 0)
dataSchemaVR2_afcData_agg <- ddply(dataSchemaVR2_afcData, 
                                   c('subNum'), 
                                   summarise, 
                                   accAFC = mean(accAFC, na.rm = TRUE))

# Calculateing tests
t.test(dataSchemaVR2_recallData_agg$accRecall - 1/20)
t.test(dataSchemaVR2_afcData_agg$accAFC - 1/3)
cor.test(dataSchemaVR2_recallData_agg$accRecall, dataSchemaVR2_afcData_agg$accAFC)

```


### Effect of general expectancy (hypothesis 1)
```{r}
# Scaling data for analysis
dataSchemaVR2_Scaled                    <- dataSchemaVR2
dataSchemaVR2_Scaled$objLocTargetRating <- scale(dataSchemaVR2_Scaled$objLocTargetRating)
dataSchemaVR2_Scaled$targetRankPre      <- scale(dataSchemaVR2_Scaled$targetRankPre)
dataSchemaVR2_Scaled$generalRatingNorm  <- scale(dataSchemaVR2_Scaled$generalRatingNorm)
dataSchemaVR2_Scaled$generalRatingPost  <- scale(dataSchemaVR2_Scaled$generalRatingPost)
dataSchemaVR2_Scaled$objLocTargetNorm   <- scale(dataSchemaVR2_Scaled$objLocTargetNorm)

# Subsetting data
dataSchemaVR2_AFC    <- subset(dataSchemaVR2_Scaled, dataSchemaVR2_Scaled$resCon != 0)
dataSchemaVR2_recall <- subset(dataSchemaVR2_Scaled, dataSchemaVR2_Scaled$recallMemory != 0)

# 1.	The locations of objects that are generally unexpected in a kitchen are remembered better than the locations of objects that are expected in a kitchen.
# Models: The effect of general expectancy on memory performance will be modelled with a linear term and a quadratic term. There will be one model will include object/location expectancy as a covariate, one model will not. (Number of models: 2)

# Recall accuracy
schemaVR2_model1 <- glmer(accRecall ~  generalRatingPost +
                            I(generalRatingPost*generalRatingPost) +
                            (1 | subNum),
                          data = dataSchemaVR2_recall,
                          family = binomial,
                          control = glmerControl(optimizer = "bobyqa"),
                          nAGQ = 1)

createResultTable(schemaVR2_model1)


schemaVR2_model2 <- glmer(accRecall ~  generalRatingPost +
                            I(generalRatingPost*generalRatingPost) +
                            objLocTargetRating +
                            (1 | subNum) +
                            (1 | objNum), 
                          data = dataSchemaVR2_recall,
                          family = binomial,
                          control = glmerControl(optimizer = "bobyqa"),
                          nAGQ = 1)


createResultTable(schemaVR2_model2)


# Euclidean distance
schemaVR2_model3 <- lmer(euclideanDist ~  generalRatingPost +
                           I(generalRatingPost*generalRatingPost) +
                           (1 | subNum) +
                           (1 | objNum),
                         data = dataSchemaVR2_recall)

createResultTable(schemaVR2_model3)


schemaVR2_model4 <- lmer(euclideanDist ~  generalRatingPost +
                           I(generalRatingPost*generalRatingPost) +
                           objLocTargetRating +
                           (1 | subNum) +
                           (1 | objNum), 
                         data = dataSchemaVR2_recall)

createResultTable(schemaVR2_model4)


# Answer time
schemaVR2_model5 <- lmer(answerTime ~  generalRatingPost +
                           I(generalRatingPost*generalRatingPost) +
                           (1 | subNum) +
                           (1 | objNum),
                         data = dataSchemaVR2_recall)

createResultTable(schemaVR2_model5)


schemaVR2_model6 <- lmer(answerTime ~  generalRatingPost +
                           I(generalRatingPost*generalRatingPost) +
                           objLocTargetRating +
                           (1 | subNum) +
                           (1 | objNum), 
                         data = dataSchemaVR2_recall)

createResultTable(schemaVR2_model6)

# 3AFC
schemaVR2_model7 <- glmer(accAFC ~  generalRatingPost +
                            I(generalRatingPost*generalRatingPost) +
                            (1 | subNum) +
                            (1 | objNum),
                          data = dataSchemaVR2_AFC,
                          family = binomial,
                          control = glmerControl(optimizer = "bobyqa"),
                          nAGQ = 1)

createResultTable(schemaVR2_model7)

schemaVR2_model8 <- glmer(accAFC ~  generalRatingPost +
                            I(generalRatingPost*generalRatingPost) +
                            objLocTargetRating +
                            (1 | subNum) +
                            (1 | objNum), 
                          data = dataSchemaVR2_AFC,
                          family = binomial,
                          control = glmerControl(optimizer = "bobyqa"),
                          nAGQ = 1)

createResultTable(schemaVR2_model8)
```


### Effect of object/location expectancy (hypothesis 2)
```{r}
# 2.	There will be positive quadratic relationship (U-shaped relationship) between memory performance and object/location expectancy once general expectancy of the objects is controlled for.
# Models: The effect of object/location expectancy on memory performance will be modelled with a linear term and a quadratic term. There will be one model will include general expectancy as a covariate, one model will not. (Number of models: 2)

# Recall accuracy
schemaVR2_model9 <- glmer(accRecall ~  objLocTargetRating +
                            I(objLocTargetRating*objLocTargetRating) +
                            (1 | subNum) +
                            (1 | objNum),
                          data = dataSchemaVR2_recall,
                          family = binomial,
                          control = glmerControl(optimizer = "bobyqa"),
                          nAGQ = 1)

# Changes interpretation
createResultTable(schemaVR2_model9)



schemaVR2_model10 <- glmer(accRecall ~  objLocTargetRating +
                             I(objLocTargetRating*objLocTargetRating) +
                             generalRatingPost +
                             (1 | subNum) +
                             (1 | objNum), 
                           data = dataSchemaVR2_recall,
                           family = binomial,
                           control = glmerControl(optimizer = "bobyqa"),
                           nAGQ = 1)

createResultTable(schemaVR2_model10)
```

```{r}
# Euclidean distance
schemaVR2_model11 <- lmer(euclideanDist ~  objLocTargetRating +
                            I(objLocTargetRating*objLocTargetRating) +
                            (1 | subNum) +
                            (1 | objNum),
                          data = dataSchemaVR2_recall)

createResultTable(schemaVR2_model11)

schemaVR2_model12 <- lmer(euclideanDist ~  objLocTargetRating +
                            I(objLocTargetRating*objLocTargetRating) +
                            generalRatingPost +
                            (1 | subNum) +
                            (1 | objNum), 
                          data = dataSchemaVR2_recall)


createResultTable(schemaVR2_model12)

# Answer time
schemaVR2_model13 <- lmer(answerTime ~  objLocTargetRating +
                            I(objLocTargetRating*objLocTargetRating) +
                            (1 | subNum) +
                            (1 | objNum),
                          data = dataSchemaVR2_recall)

createResultTable(schemaVR2_model13)



schemaVR2_model14 <- lmer(answerTime ~  objLocTargetRating +
                            I(objLocTargetRating*objLocTargetRating) +
                            generalRatingPost +
                            (1 | subNum) +
                            (1 | objNum), 
                          data = dataSchemaVR2_recall)

createResultTable(schemaVR2_model14)

# 3AFC
schemaVR2_model15 <- glmer(accAFC ~  objLocTargetRating +
                             I(objLocTargetRating*objLocTargetRating) +
                             (1 | subNum) +
                             (1 | objNum),
                           data = dataSchemaVR2_AFC,
                           family = binomial,
                           control = glmerControl(optimizer = "bobyqa"),
                           nAGQ = 1)

createResultTable(schemaVR2_model15)


schemaVR2_model16 <- glmer(accAFC ~  objLocTargetRating +
                             I(objLocTargetRating*objLocTargetRating) +
                             generalRatingPost +
                             (1 | subNum) +
                             (1 | objNum), 
                           data = dataSchemaVR2_AFC,
                           family = binomial,
                           control = glmerControl(optimizer = "bobyqa"),
                           nAGQ = 1)

createResultTable(schemaVR2_model16)
```

### Object/location expectancy and recollection and familiarity (hypothesis 3)
```{r}
# 3.	The benefits for expected and unexpected locations underlie different processes. Better memory for expected locations will be driven by familiarity judgements to a larger extent than the memory for unexpected locations. Conversely, better memory for unexpected locations will be driven by recollection judgements to a larger extent than the memory for expect locations.
# Tests: T tests comparing the percentage of recollection judgements for correctly placed expected and unexpected objects both for the location recall task and 3AFC task (Number of tests: 2) T tests comparing the percentage of familiarity judgements for correctly placed expected and unexpected objects both for the location recall task and 3AFC task (Number of tests: 2)

# Aggregating
schemaVR2_table4 <- ddply(dataSchemaVR2, 
                          c('objNum', 'objName'), 
                          summarise,
                          objLocTargetRating = mean(objLocTargetRating, na.rm = TRUE),
                          RecallNoMemory     = table(recallMemory)[1],
                          RecallRecollection = table(recallMemory)[2],
                          RecallFamiliarity  = table(recallMemory)[3],
                          RecallGuess        = table(recallMemory)[4],
                          RecallN            = sum(table(recallMemory)),
                          RecallRec_per      = (RecallRecollection/RecallN)*100,
                          RecallFam_per      = (RecallFamiliarity/RecallN)*100,
                          AFCNoMemory        = table(resCon)[1], 
                          AFCRecollection    = table(resCon)[2],
                          AFCFamiliarity     = table(resCon)[3],
                          AFCGuess           = table(resCon)[4],
                          AFCN               = sum(table(resCon)),
                          AFCRec_per         = (AFCRecollection/AFCN)*100,
                          AFCFam_per         = (AFCFamiliarity/AFCN)*100,
                          AFCGuess_per       = (AFCGuess/AFCN)*100)

# Median split
objLoc_expectedness <- rep('expected',dim(schemaVR2_table4)[1])
objLoc_expectedness[which(schemaVR2_table4$objLocTargetRating <= median(schemaVR2_table4$objLocTargetRating))] <- 'unexpected'

schemaVR2_table4$objLoc_expectedness <- objLoc_expectedness


# Recollectioon
t.test(RecallRec_per ~ objLoc_expectedness, schemaVR2_table4, var.equal = TRUE)
t.test(AFCRec_per ~ objLoc_expectedness, schemaVR2_table4, var.equal = TRUE)
cor.test( ~ RecallRec_per + objLocTargetRating, schemaVR2_table4)
cor.test( ~ AFCRec_per + objLocTargetRating, schemaVR2_table4)

# Familiarity
t.test(RecallFam_per ~ objLoc_expectedness, schemaVR2_table4, var.equal = TRUE)
t.test(AFCFam_per ~ objLoc_expectedness, schemaVR2_table4, var.equal = TRUE)
cor.test( ~ RecallFam_per + objLocTargetRating, schemaVR2_table4)
cor.test( ~ AFCFam_per + objLocTargetRating, schemaVR2_table4)
```


### Recollection/familiarity and time (hypothesis 4)
```{r}
# 4.	The participants will take less time for placing the objects if they recollect the location.
#Test: T test comparing the average time needed to correctly place an object when a location was recollected versus when a location was familiar or guessed (Number of tests: 1)

dataSchemaVR2 <- subset(dataSchemaVR2, subNum != 44)
dataSchemaVR2$recOrNot <- 'no recollection'
dataSchemaVR2$recOrNot[dataSchemaVR2$recallMemory == 1] <- 'recollection'

schemaVR2_recTime_data <- ddply(subset(dataSchemaVR2, recallMemory != 0),
                                   c('subNum', 'recOrNot'),
                                   summarise, 
                                   answerTime = mean(answerTime, na.rm = TRUE))

schemaVR2_recTime      <- ddply(schemaVR2_recTime_data, 
                                  c('recOrNot'),
                                  summarise, 
                                  mean = mean(answerTime, na.rm = TRUE),
                                  sd = sd(answerTime, na.rm = TRUE))

t.test(answerTime ~ recOrNot, schemaVR2_recTime_data, paired = TRUE)
```

### Recall bias (hypothesis 5)
```{r}
# 5.	Incorrectly placed objects will be placed at more expected locations because if participants guess they will be biased to more expected locations.
# Test:
# We going to compare the average object/location expectancy of correctly placed items with the average object/location expectancy of incorrectly placed objects using a t test (Number of tests: 1).


# Finding the expectancy of the closest location for an object
dataSchemaVR2$closestObjLocNorm <- NA
# Add normative location rating
for(i in 1:dim(dataSchemaVR2)[1]){
  if(!is.na(dataSchemaVR2$closestLoc[i])){
    # Necessary to use if statement because some values are NA and cannot be used to index
   dataSchemaVR2$closestObjLocNorm[i] <- dataSchemaVR2[i, paste("loc", dataSchemaVR2$closestLoc[i], sep = "")] 
  }
}

schemaVR2_recallBias_data <- ddply(subset(dataSchemaVR2, recallMemory != 0),
                                   c('subNum', 'accRecall'),
                                   summarise, 
                                   closestObjLocNorm = mean(closestObjLocNorm, na.rm = TRUE))

schemaVR2_recallBias     <- ddply(schemaVR2_recallBias_data, 
                                  c('accRecall'),
                                  summarise, 
                                  mean = mean(closestObjLocNorm, na.rm = TRUE),
                                  sd = sd(closestObjLocNorm, na.rm = TRUE))
t.test(closestObjLocNorm ~ accRecall, schemaVR2_recallBias_data, paired = TRUE)
```
